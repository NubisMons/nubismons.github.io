[{"content":"这个是关于我看李航的统计学习方法的一些记录,以防我看完就忘. 第一章统计学习及监督学习概论 什么是统计学习\n就是基于数据建构一个概率统计模型并对数据进行一个预测.\n统计学习的对象\n其实就是数据,只不过这些数据的来源是多种多样的,比如文字,图像,视频,音频数据或者是它们的组合,关于数据的有一个基本假设就是迷人同类数据具有共同的性质的数据,比如说英文的文章,网页之类的.由于它们具有统计的规律性.所以可以用概率统计方法去处理它们.\n统计学习方法的三要素 方法 = 模型+策略+算法\n模型 就是学习什么样的模型.其实就是模型的假设空间所包含的所有函数的集合.\n策略 就是按照什么样的学习准则,也就是如何选择一个最佳模型.进而衍生出损失函数与风险函数预测的好坏..损失函数度量的是模型一次预测的好坏,风险函数度量平均意义下模型预测的好坏.\n算法 指的就是学习模型的具体计算方法.统计学习基于训练数据集,根据学习策略,从假设空间中选择最优模型.也就是寻找最优解.\n过拟合与模型选择 当假设空间有不同的复杂度(例如:不同参数个数)的模型的时候,就要面临模型选择问题,我们当然是希望选择一个或者学习一个合适的模型.如果当假设空间中存在着一个\u0026quot;真\u0026quot;模型时,那么选择或者学习的模型应当要逼近这个真实的模型,也就是模型的参数向量与真模型的参数向量相近.如果是一味提高对训练数据的预测能力,所选模型的复杂度往往会比真实模型来得要高,这种现象就称之为过拟合.\n正则化与交叉验证 交叉验证,随机将数据集分成三个部分,分别为训练集,验证集,测试集.训练集即为训练模型,验证集用于模型选择,测试用于对学习模型的评估.\n感知机 感知机的这个东西起源很早,在1957年就已经提出了,但是它的分类模型在大多数时候泛化能力不强,但是原理简单,但是它是学习神经网络和深度学习的一个起点.\n感知机的模型 感知机的模型思想很简单,就是用于一个分类问题,也就是说将一堆东西,简单的分成两类,我这里举一个例子就是比如说,在一个广场上站着很多人,然后我们拿一条直线将男人和女人分开,这里可能有人会问,如果找不到怎么办?这个也就是说这个类别是线性不可分的,也就是说感知机模型并不适用.感知机模型的使用的一大前提就是这个东西是线性可分的才行.这个也就极大限制了感知机的使用场景.\n用数学的语言来说其实就是,有M个样本,每个样本对应着一个n维特征和一个二元输出,如下: $(x_1^0,x_2^0,x_3^0,\u0026hellip;,x_n^0,y_0),(x_1^1,x_2^1,x_3^1,\u0026hellip;,x_n^1,y_1),\u0026hellip;,到n$\n我们的一个目标其实就是找到一个超平面,即: $\\theta_0+\\theta_1x_1+\u0026hellip;+\\theta_nx_n = 0$ 让其中的一个类别都满足$\\theta_0+\\theta_1x_1+\u0026hellip;+\\theta_nx_n\u0026gt;0$ 或让其中一个$\u0026lt;0$,为了可以简化这种写法,我们其实可以加一个特征$x_0=1$,这样也就是$\\sum_{i=0}^n\\theta_ix_i=0$,其实用向量来表示就是$\\theta \\cdot x = 0$,而向量机的模型我们可以表示为, y = sign($\\theta \\cdot x$). $$ sign(x) = \\begin{cases} -1 \u0026 x \u003c 0 \\\\ 1 \u0026 x \\geq 0 \\end{cases} $$ 感知机的损失函数 我们这个损失函数其实就是为了优化模型,感知机的损失函数它的优化目标就是期望使所有错误分类的样本到超平面的距离之和最小.\n逻辑回归 逻辑回归（Logistic Regression）是统计学习中的经典分类算法，虽然名字中有\u0026quot;回归\u0026quot;，但它实际上是一种分类方法。它通过logistic函数将线性回归的输出映射到(0,1)区间，从而实现概率预测。\n1. 逻辑回归的基本思想 逻辑回归的核心思想是：\n使用sigmoid函数将线性函数的输出映射到概率值 通过最大似然估计来求解参数 适用于二分类和多分类问题 与线性回归不同，逻辑回归不是直接预测连续值，而是预测某个事件发生的概率。\n2. 逻辑回归的数学模型 2.1 Sigmoid函数 Sigmoid函数（也称为logistic函数）定义为： $$\\sigma(z) = \\frac{1}{1 + e^{-z}}$$其中 $z = \\theta_0 + \\theta_1x_1 + \\theta_2x_2 + \u0026hellip; + \\theta_nx_n = \\theta^T x$\nSigmoid函数具有以下重要性质：\n函数值域为(0,1)，可以表示概率 单调递增 在z=0处，$\\sigma(0) = 0.5$ 当z→+∞时，$\\sigma(z)→1$；当z→-∞时，$\\sigma(z)→0$ 2.2 逻辑回归模型 对于二分类问题，逻辑回归模型表示为： $$P(Y=1|x) = \\frac{1}{1 + e^{-\\theta^T x}}$$ $$P(Y=0|x) = 1 - P(Y=1|x) = \\frac{e^{-\\theta^T x}}{1 + e^{-\\theta^T x}}$$3. 几率(Odds)与对数几率(Log-Odds) 3.1 几率 几率定义为事件发生的概率与不发生概率的比值： $$odds = \\frac{P(Y=1|x)}{P(Y=0|x)} = \\frac{P(Y=1|x)}{1-P(Y=1|x)}$$3.2 对数几率（Logit） 对数几率是几率的对数： $$logit(p) = \\ln\\left(\\frac{p}{1-p}\\right) = \\theta^T x$$这说明逻辑回归实际上是在对对数几率进行线性建模。\n4. 参数估计：最大似然估计 4.1 似然函数 给定训练集 ${(x_i, y_i)}_{i=1}^m$，其中 $y_i \\in {0,1}$，似然函数为： $$L(\\theta) = \\prod_{i=1}^m P(y_i|x_i;\\theta)$$具体地： $$L(\\theta) = \\prod_{i=1}^m [P(Y=1|x_i)]^{y_i} [P(Y=0|x_i)]^{1-y_i}$$4.2 对数似然函数 取对数得到对数似然函数： $$\\ell(\\theta) = \\sum_{i=1}^m [y_i \\log P(Y=1|x_i) + (1-y_i) \\log P(Y=0|x_i)]$$代入sigmoid函数： $$\\ell(\\theta) = \\sum_{i=1}^m [y_i \\theta^T x_i - \\log(1 + e^{\\theta^T x_i})]$$4.3 梯度计算 对$\\theta$求偏导： $$\\frac{\\partial \\ell(\\theta)}{\\partial \\theta} = \\sum_{i=1}^m (y_i - \\sigma(\\theta^T x_i))x_i$$由于对数似然函数是凹函数，可以使用梯度上升法或牛顿法求解最优参数。\n5. 损失函数：交叉熵损失 逻辑回归的损失函数通常使用交叉熵损失（Cross-Entropy Loss）： $$J(\\theta) = -\\frac{1}{m}\\sum_{i=1}^m [y_i \\log h_\\theta(x_i) + (1-y_i) \\log(1-h_\\theta(x_i))]$$其中 $h_\\theta(x_i) = \\sigma(\\theta^T x_i)$ 是预测概率。\n6. 优化算法 6.1 梯度下降法详细推导 梯度下降法是通过迭代优化来最小化损失函数的方法。下面详细推导逻辑回归中梯度下降的计算过程。\n6.1.1 损失函数回顾 逻辑回归的损失函数（交叉熵损失）为： $$J(\\theta) = -\\frac{1}{m}\\sum_{i=1}^m [y_i \\log h_\\theta(x_i) + (1-y_i) \\log(1-h_\\theta(x_i))]$$其中：\n$h_\\theta(x_i) = \\sigma(\\theta^T x_i) = \\frac{1}{1 + e^{-\\theta^T x_i}}$ 是预测概率 $m$ 是训练样本数量 $y_i \\in {0,1}$ 是真实标签 6.1.2 梯度计算的详细推导 我们需要计算 $\\frac{\\partial J(\\theta)}{\\partial \\theta_j}$，其中 $\\theta_j$ 是参数向量 $\\theta$ 的第 $j$ 个分量。\n步骤1：单个样本的损失函数梯度\n对于单个样本 $(x_i, y_i)$，损失函数为： $$J_i(\\theta) = -[y_i \\log h_\\theta(x_i) + (1-y_i) \\log(1-h_\\theta(x_i))]$$首先计算 $\\frac{\\partial h_\\theta(x_i)}{\\partial \\theta_j}$：\n$$\\frac{\\partial h_\\theta(x_i)}{\\partial \\theta_j} = \\frac{\\partial}{\\partial \\theta_j} \\sigma(\\theta^T x_i) = \\frac{\\partial}{\\partial \\theta_j} \\frac{1}{1 + e^{-\\theta^T x_i}}$$使用链式法则： $$\\frac{\\partial h_\\theta(x_i)}{\\partial \\theta_j} = \\frac{\\partial \\sigma(z)}{\\partial z} \\cdot \\frac{\\partial z}{\\partial \\theta_j}$$其中 $z = \\theta^T x_i$，所以 $\\frac{\\partial z}{\\partial \\theta_j} = x_{ij}$\nSigmoid函数的导数为： $$\\frac{\\partial \\sigma(z)}{\\partial z} = \\sigma(z)(1-\\sigma(z)) = h_\\theta(x_i)(1-h_\\theta(x_i))$$因此： $$\\frac{\\partial h_\\theta(x_i)}{\\partial \\theta_j} = h_\\theta(x_i)(1-h_\\theta(x_i)) \\cdot x_{ij}$$步骤2：计算单个样本损失函数的梯度\n$$\\frac{\\partial J_i(\\theta)}{\\partial \\theta_j} = -\\left[y_i \\frac{1}{h_\\theta(x_i)} \\frac{\\partial h_\\theta(x_i)}{\\partial \\theta_j} + (1-y_i) \\frac{1}{1-h_\\theta(x_i)} \\frac{\\partial (1-h_\\theta(x_i))}{\\partial \\theta_j}\\right]$$注意到： $$\\frac{\\partial (1-h_\\theta(x_i))}{\\partial \\theta_j} = -\\frac{\\partial h_\\theta(x_i)}{\\partial \\theta_j}$$代入得： $$\\frac{\\partial J_i(\\theta)}{\\partial \\theta_j} = -\\left[y_i \\frac{1}{h_\\theta(x_i)} - (1-y_i) \\frac{1}{1-h_\\theta(x_i)}\\right] \\frac{\\partial h_\\theta(x_i)}{\\partial \\theta_j}$$$$= -\\left[\\frac{y_i}{h_\\theta(x_i)} - \\frac{1-y_i}{1-h_\\theta(x_i)}\\right] h_\\theta(x_i)(1-h_\\theta(x_i)) x_{ij}$$$$= -\\left[y_i(1-h_\\theta(x_i)) - (1-y_i)h_\\theta(x_i)\\right] x_{ij}$$$$= -[y_i - y_ih_\\theta(x_i) - h_\\theta(x_i) + y_ih_\\theta(x_i)] x_{ij}$$$$= -[y_i - h_\\theta(x_i)] x_{ij}$$$$= (h_\\theta(x_i) - y_i) x_{ij}$$步骤3：整体损失函数的梯度\n对所有样本求平均： $$\\frac{\\partial J(\\theta)}{\\partial \\theta_j} = \\frac{1}{m}\\sum_{i=1}^m (h_\\theta(x_i) - y_i) x_{ij}$$用向量形式表示： $$\\frac{\\partial J(\\theta)}{\\partial \\theta} = \\frac{1}{m} X^T (h_\\theta(X) - y)$$其中：\n$X$ 是 $m \\times n$ 的特征矩阵 $h_\\theta(X) = [\\sigma(\\theta^T x_1), \\sigma(\\theta^T x_2), \u0026hellip;, \\sigma(\\theta^T x_m)]^T$ $y = [y_1, y_2, \u0026hellip;, y_m]^T$ 6.1.3 梯度下降更新规则 梯度下降的更新规则为： $$\\theta^{(t+1)} = \\theta^{(t)} - \\alpha \\frac{\\partial J(\\theta^{(t)})}{\\partial \\theta}$$具体地： $$\\theta^{(t+1)} = \\theta^{(t)} - \\frac{\\alpha}{m} X^T (h_\\theta(X) - y)$$对于每个参数分量： $$\\theta_j^{(t+1)} = \\theta_j^{(t)} - \\frac{\\alpha}{m} \\sum_{i=1}^m (h_\\theta(x_i) - y_i) x_{ij}$$6.1.4 算法流程 初始化：随机初始化参数 $\\theta^{(0)}$ 迭代更新：对于 $t = 0, 1, 2, \u0026hellip;$ 计算预测值：$h_\\theta(x_i) = \\sigma(\\theta^T x_i)$ 计算梯度：$\\nabla J(\\theta) = \\frac{1}{m} X^T (h_\\theta(X) - y)$ 更新参数：$\\theta^{(t+1)} = \\theta^{(t)} - \\alpha \\nabla J(\\theta^{(t)})$ 收敛判断：当 $||\\nabla J(\\theta)||$ 小于阈值或达到最大迭代次数时停止 6.1.5 学习率的选择 学习率 $\\alpha$ 的选择非常重要：\n太大：可能导致震荡，无法收敛 太小：收敛速度很慢 自适应学习率：随着迭代次数增加而减小 常用的学习率策略： $$\\alpha^{(t)} = \\frac{\\alpha_0}{1 + \\text{decay\\_rate} \\times t}$$6.1.6 梯度下降的几何解释 从几何角度看，梯度 $\\nabla J(\\theta)$ 指向损失函数增长最快的方向，因此：\n负梯度方向 $-\\nabla J(\\theta)$ 是函数值下降最快的方向 梯度下降沿着负梯度方向移动，逐步找到最优解 步长由学习率 $\\alpha$ 控制 6.2 牛顿法 利用二阶导数信息，收敛更快： $$\\theta := \\theta - H^{-1} \\nabla J(\\theta)$$其中 $H$ 是Hessian矩阵。\n7. 逻辑回归的优缺点 7.1 优点 模型简单：线性模型，易于理解和实现 计算效率高：训练和预测速度快 概率输出：直接给出分类概率，便于决策 无需特征缩放：对特征尺度不敏感 不需要调参：相对稳定，超参数较少 7.2 缺点 线性假设：只能处理线性可分问题 对离群点敏感：极端值会影响模型性能 特征工程要求高：需要人工构造有效特征 多重共线性问题：特征间相关性影响模型稳定性 8. 正则化逻辑回归 为了防止过拟合，可以加入正则化项：\n8.1 L1正则化（Lasso） $$J(\\theta) = -\\frac{1}{m}\\sum_{i=1}^m [y_i \\log h_\\theta(x_i) + (1-y_i) \\log(1-h_\\theta(x_i))] + \\lambda \\sum_{j=1}^n |\\theta_j|$$8.2 L2正则化（Ridge） $$J(\\theta) = -\\frac{1}{m}\\sum_{i=1}^m [y_i \\log h_\\theta(x_i) + (1-y_i) \\log(1-h_\\theta(x_i))] + \\lambda \\sum_{j=1}^n \\theta_j^2$$8.3 弹性网络（Elastic Net） 结合L1和L2正则化： $$J(\\theta) = -\\frac{1}{m}\\sum_{i=1}^m [y_i \\log h_\\theta(x_i) + (1-y_i) \\log(1-h_\\theta(x_i))] + \\lambda_1 \\sum_{j=1}^n |\\theta_j| + \\lambda_2 \\sum_{j=1}^n \\theta_j^2$$9. 多分类逻辑回归 9.1 一对一（One-vs-One） 对于K个类别，训练$\\frac{K(K-1)}{2}$个二分类器。\n9.2 一对其余（One-vs-Rest） 对于K个类别，训练K个二分类器，每个分类器区分一个类别与其他所有类别。\n9.3 Softmax回归（多项逻辑回归） 直接扩展到多分类： $$P(Y=k|x) = \\frac{e^{\\theta_k^T x}}{\\sum_{j=1}^K e^{\\theta_j^T x}}$$10. 模型评估指标 准确率（Accuracy）：正确预测的比例 精确率（Precision）：预测为正例中实际为正例的比例 召回率（Recall）：实际正例中被正确预测的比例 F1-Score：精确率和召回率的调和平均 AUC-ROC：ROC曲线下的面积 对数损失（Log Loss）：衡量概率预测的质量 11. 实际应用场景 医疗诊断：根据症状预测疾病概率 金融风控：信用评分，违约概率预测 市场营销：客户响应率预测 推荐系统：用户点击率预测 文本分类：垃圾邮件检测 图像识别：简单的二分类任务 12. 与其他算法的比较 特征 逻辑回归 线性回归 SVM 决策树 输出类型 概率 连续值 分类/回归 分类/回归 模型复杂度 低 低 中等 高 可解释性 强 强 中等 强 处理非线性 弱 弱 强（核函数） 强 训练速度 快 快 中等 快 13. 总结 逻辑回归是机器学习中的基础且重要的算法，具有以下关键特点：\n数学基础扎实：基于最大似然估计，理论完备 实现简单：模型结构清晰，易于编程实现 应用广泛：在工业界有大量实际应用 可解释性强：参数具有明确的物理意义 计算效率高：训练和预测速度快 虽然逻辑回归在处理复杂非线性问题时有局限性，但它仍然是分类问题的首选baseline算法，也是理解更复杂机器学习算法的重要基础。\n","date":"2025-05-16T15:41:51+08:00","permalink":"https://blogbook.eu.org/p/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/","title":"统计学习方法"},{"content":"起源 这本小说我其实很早就已经听说了,但是一直没有机会看,所以我趁我现在时间比较充裕所以开始看一下这本小说,接下来我将分享一下我的一些读后感什么的,也算是一个记录吧,做一个存档,以方便看到我当时是怎么想的.也把自己的所思所想记录下来,也有一个原因就是,随着我的年龄的增加我发现时间过得越来越快,所以我也要开始善于捕捉我日常的一些所思所想,避免这个有匆匆过了一年又一年.也可以锻炼一下我文笔吧,毕竟我不怎么输出自己的想法,把自己日常的想法进行记录下来也是一件挺有意思的事情.虽然这个博客系统我本来其实拿来记录我的学习的,但是掺一点自己的想法也是可以的,反正这个博客估计也是不会有人看的,所以的我就把这里当成自己的一个树洞.在这里写一些自己的想法.就随心所欲即可.\n","date":"2025-05-14T23:31:21+08:00","permalink":"https://blogbook.eu.org/p/%E8%83%A1%E9%9B%AA%E5%B2%A9%E5%B0%8F%E8%AF%B4/","title":"胡雪岩小说"},{"content":"基本概念 随机试验\n可以在相同的条件下重复进行. 每次实验的结果可能不止一个,且能事先明确所有结果. 进行一次试验之前不能确定哪一个结果会出现. 样本空间\n随机试验所有可能结果的集合\n基本事件\n由一个样本点组成的单点集\n必然事件\n每次试验中都必然发生的事件(S事件)\n不可能事件\n每次试验中都不可能发生的事件,也就是一个空集\n事件的关系与运算 包含\n$A \\subset B$,表示A发生B必然发生\n和事件\n$A \\cup B$,表示A与B至少有一个发生\n积事件\n$A \\cap B$或$AB$,表示A与B同时发生\n// \u0026hellip;existing code\u0026hellip;\n运算律 交换律: $A\\cup B=B\\cup A$ 结合律: $(A\\cup B)\\cup C = A\\cup (B\\cup C)$ 分配律: $(A\\cup B)\\cap C = (A\\cap C)\\cup (B\\cap C)$ 德摩根定律: $\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}$ $\\overline{A \\cap B} = \\overline{A} \\cup \\overline{B}$ 概率的定义与性质 古典概型概率: $P(A) = A$ 包含的基本事件数/S中基本事件的总数.\n这个S,是所有事件的总数\n几何概型概率: $P(A)=A$ 的几何度量/S的几何度量\n统计概率$P(A)= \\lim_{n \\to \\infty}(nA/n)$, nA为A发生的总数\n公理化定义: 基于一组公理来定义概率,这也就是现代概率论的基础.\n对于任意事件$A,P(A)\\geq 0$ $P(A)=1$ 表示这个事件是一定会发生 对于互不相容的事件序列$A_1,A_2,\u0026hellip;$,有: $P(A_1 \\cup A_2 \\cup \u0026hellip;) = P(A_1) + P(A_2) + \u0026hellip;$ 概率的类型 古典概率: 当样本空间是有限的且所有基本事件发生的可能性相等时,事件 A 的概率定义为 A 包含的基本事件数与样本空间中基本事件总数的比值。 $$P(A)\\approx\\frac{事件A包含的基本事件数}{样本空间的基本是将总数}$$ 经验概率: 通过大量的重复试验,事件A发生的概率趋于一个稳定值,将这个稳定值作为事件A的概率估计. $$P(A)\\approx\\frac{事件A发生的次数}{重复试验的总次数}$$ 独立事件 核心概率:\n如果两件事情的发生互不影响,那么它们就是独立事件.也就是说,一个事件的发生或不发生并不会改变另一个事件发生的概率.\n正式的定义:\n对于两个事件 A 和 B，如果满足以下任一条件（这些条件是等价的，只要其中一个成立，其他也成立），则称 A 和 B 是独立事件：\n联合概率的乘积: $$P(A\\cap B)=P(A)P(B)$$ 这是独立事件最常用的定义，也是最普遍适用的定义.即使这个$P(A)=0$或者$P(B)=0$也是适用的. 联合概率 联合概率其实就是指两个或多个事件同时发生的概率.对于两个事件A和B,它们的联合概率记为$P(A\\cap B)$或P(A,B).$A\\cap B$表示就是事件A与B的发生交集.\n核心思想: 与单个事件的概率$P(A)$(只关心A是否发生)或B是否发生不同，联合概率关心的是A和B两个条件是否同时满足．\n\u0026ldquo;统计\u0026quot;的含义与联合概率 当提到\u0026quot;联合统计\u0026quot;时,它通常有两种含义:\n通过统计数据估计联合概率: 这也是最常见的做法.在实际的应用中,我们往往无法得知事件的真实概率,而是通过收集大量数据(统计数据),计算两个事件同时发生的频率来估算它们的联合概率. $$P(A\\cap B)\\approx\\frac{事件A和事件B同时发生的次数} {总试验或观察的次数}$$ 这种方法其实就是基于大数定律的经验公式.\n联合概率分布的概率: 对于随机变量,我们讨论它们的联合概率分布.这描述了两个或多个随机变量同时取特定值或落在特定范围内的概率。在统计学中，我们经常从样本数据来推断或描述这种联合分布. ","date":"2025-04-27T05:32:32+08:00","permalink":"https://blogbook.eu.org/p/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E4%B8%8E%E6%A6%82%E7%8E%87%E8%AE%BA/","title":"数理统计与概率论"},{"content":"本文仅记录一些我的学习这篇论文记录 什么是卷积神经网络 卷积这个东西有三层含义: 1.第一个就是稳定的输出和不稳定的输入求其的系统存量 2.周围像素点是如何影响的 3.一个像素点的试探,就是起到一个过滤器的作用把我们需要的特征提取出来\n什么是神经网络 1.旧的感知机无法实现异或运算,感知机与现有计算机的区别,它优势在哪里,感知机是一种分类工具,用随机梯度下降法,用数据去进行一个训练把分类的标准进行一个调整.感知机有标准能判断,在一个n维的情况下进行判别,使用n-1维去判断(就是进行一个分割,就是一个立体的东西进行一个切割,我们就要用到一个面,而一个面进行切割我们就要用到一个一根线,就是说一个n维的东西就行切割我们要用n-1维的去切割分类)还有就是只能进行线性分割.感知机使用一个统一模板对东西进行分类,就是一个线性函数加一个激活函数(判断函数), 具体的表达 $t=f(\\sum=w_ix_i+b=f(w^Tx))$ 感知机的缺陷就是没有办法处理异或问题,因为异或问题没有办法进行线性可分 为了解决这个问题提出多层神经网络,通过多个感知机进行解决 盖尔定理进行如果在低维的情况下想要进行线性可分比较困难,那我们可以进行一个升维进行\n测试 ","date":"2023-03-26T20:18:58Z","permalink":"https://blogbook.eu.org/p/%E5%9B%BE%E5%83%8F%E5%88%B0%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BF%BB%E8%AF%91%E7%9A%84%E5%85%B7%E6%9C%89%E8%87%AA%E9%80%82%E5%BA%94%E5%AE%9E%E4%BE%8B%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E7%94%9F%E6%88%90%E6%B3%A8%E6%84%8F%E7%BD%91%E7%BB%9C/","title":"图像到图像的翻译的具有自适应实例归一化的无监督生成注意网络"},{"content":"问题描述 首先就是大家发现c++更新到1.8.4之后的版本后发现这个launch文件无法自动生成了.\n问题解决方案 第一个 就是清楚这个文件如何配置,照着配一个就行,但是鉴于这个难度颇高,所以并不建议大家这样做.\n第二个 就是将这个C/C++的版本退回到可以自我生成的哪个版本,也就是1.8.4的版本即可.\n第三个 这个是参照官网的办法就是先生成调试文件再运行,这个也是我推荐的方法\n首先就是打开代码的源文件,然后按这个按钮即可生成task.json和launch.json两个主要文件.\n","date":"2023-02-14T19:08:07Z","permalink":"https://blogbook.eu.org/p/%E5%85%B3%E4%BA%8E%E5%9C%A8vscode%E4%B8%ADc-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90launch.json%E7%9A%84%E9%97%AE%E9%A2%98/","title":"关于在Vscode中c++无法自动生成launch.json的问题"},{"content":"问题描述 使用vscode,在markdown的预览模式下无法加载预览图片问题\n本机环境 该问题与操作系统基本无关,本机markdown使用picgo+github做图床\nmarkdown的插件主要为: 解决方案 设置好两个地方即可\n第一个是修改预览的安全策略 按快捷键Ctrl+Shift+P，搜索markdown更改预览安全设置，选择允许不安全内容，即可显示预览网页图片 第二个是配置github的域名解析 对于使用picgo + github作为图床的，还需要设置一下域名解析。\npicgo + github作为图床自动生成的类似如下地址，无法解析，直接点击在浏览器中也无法打开\nhttps://raw.githubusercontent.com/ljy18/picgo/main/20221113221343.png\n选择一个或多个，比如185.199.108.133， 将它写入到C:\\Windows\\System32\\drivers\\etc\\hosts文件中，如下所示\n1 2 3 4 185.199.108.133 raw.githubusercontent.com 185.199.109.133 raw.githubusercontent.com 185.199.110.133 raw.githubusercontent.com 185.199.111.133 raw.githubusercontent.com ","date":"2023-02-07T22:29:44Z","permalink":"https://blogbook.eu.org/p/vscode-%E4%B8%ADmarkdown%E4%B8%8D%E8%83%BD%E6%98%BE%E7%A4%BA%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/","title":"Vscode 中markdown不能显示预览图片问题"},{"content":"一、tasks.json 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活动文件\u0026#34;, //注意这里填你自己 mingw-w64 下的 gcc.exe 目录 \u0026#34;command\u0026#34;: \u0026#34;E:\\\\software\\\\mingw-w64\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-fdiagnostics-color=always\u0026#34;, \u0026#34;-g\u0026#34;, //\u0026#34;${file}\u0026#34;, \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;detail\u0026#34;: \u0026#34;调试器生成的任务。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 可以看到，我把原本的 \u0026ldquo;${file}\u0026rdquo; 注释掉了，换成 \u0026ldquo;${fileDirname}\\.c\u0026rdquo;，这是在同一个文件夹中支持编译多个 c 文件，如果要编译多个 cpp 文件，则改成 \u0026ldquo;${fileDirname}\\.cpp\u0026rdquo; 即可。\nsettings.json 配置 这个怎么找到呢？按下 ctrl+shift+p 或者 F1，打开控制面板，输入 settings.json，点击即可。\nsettings.json:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 { \u0026#34;editor.fontSize\u0026#34;: 17, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;vscode-icons\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Noctis Viola\u0026#34;, \u0026#34;editor.minimap.enabled\u0026#34;: true, \u0026#34;C_Cpp.autocomplete\u0026#34;: \u0026#34;Default\u0026#34;, \u0026#34;[cpp]\u0026#34;: { \u0026#34;editor.quickSuggestions\u0026#34;: true }, \u0026#34;[c]\u0026#34;: { \u0026#34;editor.quickSuggestions\u0026#34;: true }, \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34;, \u0026#34;code-runner.executorMap\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;java\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; javac $fileName \u0026amp;\u0026amp; java $fileNameWithoutExt\u0026#34;, //\u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc *.c -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, //\u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ *.cpp -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;objective-c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc -framework Cocoa $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;php\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;python\u0026#34;: \u0026#34;python -u\u0026#34;, \u0026#34;perl\u0026#34;: \u0026#34;perl\u0026#34;, \u0026#34;perl6\u0026#34;: \u0026#34;perl6\u0026#34;, \u0026#34;ruby\u0026#34;: \u0026#34;ruby\u0026#34;, \u0026#34;go\u0026#34;: \u0026#34;go run\u0026#34;, \u0026#34;lua\u0026#34;: \u0026#34;lua\u0026#34;, \u0026#34;groovy\u0026#34;: \u0026#34;groovy\u0026#34;, \u0026#34;powershell\u0026#34;: \u0026#34;powershell -ExecutionPolicy ByPass -File\u0026#34;, \u0026#34;bat\u0026#34;: \u0026#34;cmd /c\u0026#34;, \u0026#34;shellscript\u0026#34;: \u0026#34;bash\u0026#34;, \u0026#34;fsharp\u0026#34;: \u0026#34;fsi\u0026#34;, \u0026#34;csharp\u0026#34;: \u0026#34;scriptcs\u0026#34;, \u0026#34;vbscript\u0026#34;: \u0026#34;cscript //Nologo\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;ts-node\u0026#34;, \u0026#34;coffeescript\u0026#34;: \u0026#34;coffee\u0026#34;, \u0026#34;scala\u0026#34;: \u0026#34;scala\u0026#34;, \u0026#34;swift\u0026#34;: \u0026#34;swift\u0026#34;, \u0026#34;julia\u0026#34;: \u0026#34;julia\u0026#34;, \u0026#34;crystal\u0026#34;: \u0026#34;crystal\u0026#34;, \u0026#34;ocaml\u0026#34;: \u0026#34;ocaml\u0026#34;, \u0026#34;r\u0026#34;: \u0026#34;Rscript\u0026#34;, \u0026#34;applescript\u0026#34;: \u0026#34;osascript\u0026#34;, \u0026#34;clojure\u0026#34;: \u0026#34;lein exec\u0026#34;, \u0026#34;haxe\u0026#34;: \u0026#34;haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt\u0026#34;, \u0026#34;rust\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; rustc $fileName \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;racket\u0026#34;: \u0026#34;racket\u0026#34;, \u0026#34;scheme\u0026#34;: \u0026#34;csi -script\u0026#34;, \u0026#34;ahk\u0026#34;: \u0026#34;autohotkey\u0026#34;, \u0026#34;autoit\u0026#34;: \u0026#34;autoit3\u0026#34;, \u0026#34;dart\u0026#34;: \u0026#34;dart\u0026#34;, \u0026#34;pascal\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; fpc $fileName \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;d\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; dmd $fileName \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;haskell\u0026#34;: \u0026#34;runhaskell\u0026#34;, \u0026#34;nim\u0026#34;: \u0026#34;nim compile --verbosity:0 --hints:off --run\u0026#34;, \u0026#34;lisp\u0026#34;: \u0026#34;sbcl --script\u0026#34;, \u0026#34;kit\u0026#34;: \u0026#34;kitc --run\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;v run\u0026#34;, \u0026#34;sass\u0026#34;: \u0026#34;sass --style expanded\u0026#34;, \u0026#34;scss\u0026#34;: \u0026#34;scss --style expanded\u0026#34;, \u0026#34;less\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; lessc $fileName $fileNameWithoutExt.css\u0026#34;, \u0026#34;FortranFreeForm\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gfortran $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;fortran-modern\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gfortran $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;fortran_fixed-form\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gfortran $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;fortran\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gfortran $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34; }, \u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;PowerShell\u0026#34; } 注意看我注释部分，如果你想编译多个 c 文件，把 \u0026ldquo;c\u0026rdquo;: \u0026ldquo;cd $dir \u0026amp;\u0026amp; gcc $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026rdquo; 改成 \u0026ldquo;c\u0026rdquo;: \u0026ldquo;cd $dir \u0026amp;\u0026amp; gcc *.c -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026rdquo; 即可，如果你想编译多个 cpp 文件，把 \u0026ldquo;cpp\u0026rdquo;: \u0026ldquo;cd $dir \u0026amp;\u0026amp; g++ $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026rdquo; 改成 \u0026ldquo;cpp\u0026rdquo;: \u0026ldquo;cd $dir \u0026amp;\u0026amp; g++ *.cpp -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026rdquo; 即可。 p\n","date":"2023-02-07T17:53:53Z","permalink":"https://blogbook.eu.org/p/vscode%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E7%BC%96%E8%AF%91%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6/","title":"Vscode在一个文件夹里编译多个文件"},{"content":"计算机的基本组成构件 冯诺依曼型的的计算机是由运算器,输入输出,存储器(指令和数据,按址寻访),控制器组成的 指令和数据以同等的地位进行存储 指令和数据用二进制进行表示 指令是由操作码和地址码组成 存储程序 以运算器为中心 因为其以运算器为中心所以这个计算机的能力受到了运算器的运算能力的限制,也有其改进型以存储器为中心\nCPU CPU主要由控制器和运算器构成,而控制器是由PC(program Counter)程序计数器,IR(Instruction Register)指令寄存器,CU(Control Unit)组成,PC存放执行指令的地址,而IR是存放当前取出的指令,CU操作控制.运算器是由ACC(ACCumulator)累加器,ALU算术逻辑单元,MQ(Multiplier-Quotient Register)乘商寄存器,X为操作数寄存器组成\n主存储器 主存储器是由MAR(Memory Address Register)存储器地址寄存器,MDR(Memory Data Register)寄存器数据寄存器,存储体M组成.MAR是存放欲访问存储单元的地址,MDR是存放从存储体某单元取出的代码或者往某存储单元存入的代码.\n一般指令的完成过程 三步走:\n取指令 分析指令 执行指令 举一个具体的例子 取数指令的执行过程:首先pc-\u0026gt;MAR-\u0026gt;M-\u0026gt;MDR-\u0026gt;IR 分析指令: (OP)IR\u0026ndash;\u0026gt;CU 执行指令: IR-\u0026gt;MAR-\u0026gt;M-\u0026gt;MDR-\u0026gt;ACC\n复杂系统的管理方法 层次化(Hierarchy) 多个模块 模块化(Modularity) 每个模块都有(well-defined)的功能和接口 规则化(Regularly) 让模块更容易被重用 ","date":"2023-01-14T16:00:32Z","permalink":"https://blogbook.eu.org/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/","title":"计算机的基本组成"},{"content":"前期提示 以下东西纯属个人消化\n缘由 首先说一下写这个东西的原因:就是这个卷积公式的理解一直都是我学习信号与系统的拦路虎,一直无法理解这个是什么东西,终于在今晚弄懂了我滴天啊!\n卷积公式的形式 首先来看一下这个卷积公式的形式 积分形式\n$$(f*g)(n)=\\int^{+\\infty}_{-\\infty}f(\\tau)g(n-\\tau)d{\\tau}$$离散形式\n$$(f*g)(n)=\\sum^{+\\infty}_{-\\infty}f(\\tau)g(n-\\tau)$$翻卷 其实吧,我一直没办法就是为什么那个$f(\\tau)$要乘于一个负的$g(n-\\tau)$,我认为关键就是理解的这个$-\\tau$,理解了这个就理解了整个公式.\n举一个例子 扔石头 往水面仍石头,我们把水面的反应当成的一个冲击反应,我们在t=0时,扔下一个石头会激起一个h(0)的波纹,但是水面不会立刻平静,随着时间的流逝，波纹幅度会越来越小，在t=1时刻，幅度衰减为h(1), 在t=2时刻，幅度衰减为h(2)……直到一段时间后，水面重复归于平静.\n从时间轴上来看，我们只在t=0时刻丢了一块石头，其它时刻并没有做任何事，但在t=1,2….时刻，水面是不平静的，这是因为过去（t=0时刻）的作用一直持续到了现在。那么，问题来了：如果我们在t=1时刻也丢入一块石子呢？此时t=0时刻的影响还没有消失（水面还没有恢复平静）新的石子又丢进来了，那么现在激起的波浪有多高呢？答案是当前激起的波浪与t=0时刻残余的影响的叠加。那么t=0时刻对t=1时刻的残余影响有多大呢？为了便于说明，接下来我们作一下两个假设：\n1． 水面对于“单位石块”的响应是固定的. 2． 丢一个两倍于的“单位石块”的石块激起的波纹高度是丢一个石块的两倍（即系统满足线性叠加原理）现在我们来计算每一时刻的波浪有多高: 那么我们一个时刻就扔一个石头,t=0,t=1,t=2时,以此类推.那么我们来算一下每个时水面的反应:\ny为水面的反应,x为石子,h为水面的激起波澜的函数\nt=0时: y(0)=x(0)*h(0)//t0时刻一个石子在h0时刻激起y0\nt=1时 y(1)=x(1)*h(0)+x(0)*h(1)//这个就是当前石子激起h(0),和之前那个x(0)那个的残余的叠加\nt=2时: y(2)=x(2)*h(0)+x(1)*h(1)+x(0)*h(2)\n以此类推\nt=n 时: y(n)=x(n)*h(0)+x(n-1)*h(1)+x(n-2)*h(2)+\u0026hellip;+x(0)*h(n) 推到这一步把用累加符号弄在一起你会惊讶的发现,我擦这个不就是说这个吗? $\\sum_{i=0}^nx(i)h(n-i)$是不是很是相像$(fg)(n)=\\sum^{+\\infty}_{-\\infty}f(\\tau)g(n-\\tau)$.这就是离散卷积的公式了理解了上面的问题，下面我们来看看“翻转”是怎么回事：当我们每次要丢石子时，站在当前的时间点，系统的对我们的回应都是h(0),时间轴之后的（h(1),h(2)\u0026hellip;..）都是对未来的影响。而整体的回应要加上过去对于现在的残余影响。现在我们来观察t=4这个时刻.\n站在t=0时刻看他对于未来（t=4）时刻(从现在往后4秒)的影响，可见是x(0)*h(4) 站在t=1时刻看他对于未来（t=4）时刻的影响(从现在往后3秒)，可见是x(1)*h(3) 站在t=2时刻看他对于未来（t=4）时刻的影响(从现在往后2秒)，可见是x(2)*h(2) 站在t=3时刻看他对于未来（t=4）时刻的影响(从现在往后1秒)，可见是x(3)*h(1) 图示:\n你将第一幅和第三幅对应的乘起来是不是就是那个 y(4)=x(4)*h(0)+x(3)*h(1)+x(2)*h(2)+x(1)*h(3)+x(0)*h(4)\n结论:所以所谓的翻转只是因为你站立的现在是过去的未来,所谓卷积其实就是过去对现在影响的叠加. ","date":"2022-09-11T18:50:55Z","permalink":"https://blogbook.eu.org/p/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/","title":"卷积公式"},{"content":"前言 LaTeX是一套非常优秀的排版系统， 通过它排版的图书和论文会变得非常漂亮和易读。 而LaTeX在编写数学公式的易用性和通用性，使我对它产生了浓厚的兴趣。 这篇文章主要介绍了LaTeX公式编辑在MarkDown下的使用语法和方法。 以下的例子是在Sublime Text3上编写， 并测试的结果， 当然你也可以在任何引入MathJax的MarkDown编辑器上测试。\n//启动摘要和不展示全文的小技巧\n1.显示方法 嵌入文字显示：$...$ eg: $\\sum^n_{i=1}x^i=1$ ==\u0026gt; $\\sum^n_{i=1}x^i=1$ 单行显示： $$...$$ eg: $ $\\sum^n_{i=1}x^i=1$ $ ==\u0026gt; $$\\sum^n_{i=1}x^i=1$$ 带序号显示：\\begin{equation}...\\end{equation} eg: \\begin{equation}\\sum^n_{i=1}x^i=1\\end{equation} ==\u0026gt; \\begin{equation}\\sum^n_{i=1}x^i=1\\end{equation} \\begin{equation}\\x+y=z\\end{equation} ==\u0026gt; \\begin{equation}x+y=z\\end{equation} 2.通用显示规则 ^ =\u0026gt; 上标 _ =\u0026gt; 下标 {} =\u0026gt; 包括 ~ =\u0026gt; 空格 \\ =\u0026gt; 转移符号 3.增强型显示规则 \\sqrt 求根 eg: $\\sqrt{x+y}$==\u0026gt; $\\sqrt{x+y}$ eg: $\\sqrt[3]{x+y}$==\u0026gt; $\\sqrt[3]{x+y}$\n\\frac \\over 分数形式 eg: $\\frac{a+1}{b+2}$ ==\u0026gt; $\\frac{a+1}{b+2}$ eg: ${a+1}\\over{b+2}$ ==\u0026gt; ${a+1}\\over{b+2}$\n\\sum 求和 eg: $\\sum$==\u0026gt; $\\sum$\n\\prod 求积 eg: $\\prod^n_{i=1}i+1=1$ ==\u0026gt; $\\prod^n_{i=1}i+1=1$\n\\int 求积分 eg: $\\int x+1$ ==\u0026gt; $\\int x+1$\n\\iint 求积分 eg: $\\iint x+1$ ==\u0026gt; $\\iint x+1$\n\\bigcup 并集 eg: $A\\bigcup B$ ==\u0026gt; $A\\bigcup B$\n\\cup 并集 eg: $A\\cup B$ ==\u0026gt; $A\\cup B$\n\\cap 交集 eg: $A\\cap B$ ==\u0026gt; $A\\cap B$\n\\bigcap 交集 eg: $A\\bigcap B$ ==\u0026gt; $A\\bigcap B$\n\\to 箭头 eg: $A\\to B$ ==\u0026gt; $A\\to B$\n\\lim eg: $\\lim_{0\\to 100}$ ==\u0026gt; $\\lim_{0\\to 100}$\n\\ln eg: $\\ln_{0\\to 100}$ ==\u0026gt; $\\ln_{0\\to 100}$\n\\sin eg: $\\sin x$ ==\u0026gt; $\\sin x$\n\\cos eg: $\\cos x$ ==\u0026gt; $\\cos x$\n\\qquad 8m空格\n\\quad 4m空格\n\\times 乘号 eg: $a \\times b$=$a \\times b$\n\\div 除号 eg: $a\\div b$=$a\\div b$\n\\{\\} 花括号显示 eg: $\\\\{ hello \\\\}$ ==\u0026gt; $\\{ hello \\}$ 注意：在这里我测试的Sublime Text3编写输出的结果， 如果在其他MarkDown编辑器可能要使用单反斜杠\n小括号增强 eg: $\\left( hello\\right)$ ==\u0026gt; $\\left( hello\\right)$\n中括号增强 eg: $\\left[hello\\right]$ ==\u0026gt; $\\left[hello\\right]$\n绝对值增强 eg: $\\left|hello\\right|$ ==\u0026gt; $\\left|hello\\right|$\n尖括号 eg: $\\langle hello\\rangle$ ==\u0026gt; $\\langle hello\\rangle$\n向上取整 eg: $\\lceil hello\\rceil$ ==\u0026gt; $\\lceil hello\\rceil$\n向下取整 eg: $\\lfloor hllo\\rfloor$ ==\u0026gt; $\\lfloor hllo\\rfloor$\n4.数学符号表一 符号 显示方法 符号 显示方法 符号 显示方法 $\\pm$ \\pm $\\mp$ \\mp $\\times$ \\times $\\div$ \\div $\\ast$ \\ast $\\star$ \\star $\\circ$ \\circ $\\bullet$ \\bullet $\\cdot$ \\cdot $\\oplus$ \\oplus $\\oslash$ \\oslash $\\dagger$ \\dagger $+$ + $-$ - $\\cap$ \\cap $\\cup$ \\cup $\\ddagger$ \\ddagger $\\diamond$ \\diamond $\\uplus$ \\uplus $\\sqcap$ \\sqcap $\\sqcup$ \\sqcup $\\vee$ \\vee $\\wedge$ \\wedge $\\setminus$ \\setminus $\\wr$ \\wr $\\ominus$ \\ominus $\\odot$ \\odot $\\bigtriangleup$ \\bigtriangleup $\\bigtriangledown$ \\bigtriangledown $\\triangleleft$ \\triangleleft $\\triangleright$ \\triangleright $\\lhd$ \\lhd $\\rhd$ \\rhd $\\unlhd$ \\unlhd $\\unrhd$ \\unrhd $\\otimes$ \\otimes $\\bigcirc$ \\bigcirc $\\amalg$ \\amalg $\\sum$ \\sum $\\prod$ \\prod $\\coprod$ \\coprod $\\int$ \\int $\\oint$ \\oint $\\bigcap$ \\bigcap $\\bigcup$ \\bigcup $\\bigsqcup$ \\bigsqcup $\\bigvee$ \\bigvee $\\bigwedge$ \\bigwedge $\\bigodot$ \\bigodot $\\bigotimes$ \\bigotimes $\\bigoplus$ \\bigoplus $\\biguplus$ \\biguplus $\\leq$ \\leq $\\geq$ \\geq $\\equiv$ \\equiv $\\prec$ \\prec $\\succ$ \\cucc $\\sim$ \\sim $\\preceq$ \\preceq $\\succeq$ \\succeq $\\simeq$ \\simeq $\\ll$ \\ll $\\gg$ \\gg $\\asymp$ \\asymp $\\subset$ \\subset $\\supset$ \\supset $\\approx$ \\approx $\\subseteq$ \\subseteq $\\supseteq$ \\subseteq $\\cong$ \\cong $\\sqsubset$ \\sqsubset $\\sqsupset$ \\sqsupset $\\neq$ \\neq $\\sqsubseteq$ \\sqsubseteq $\\sqsupseteq$ \\sqsupseteq $\\doteq$ \\doteq $\\in$ \\in $\\ni$ \\ni $\\notin$ \\notin $\\vdash$ \\vdash $\\dashv$ \\dashv $:$ : $\\models$ \\models $\\perp$ \\perp $\\mid$ \\mid $\\parallel$ \\parallel $\\bowtie$ \\bowtie $\\Join$ \\Join $\\smile$ \\smile $\\frown$ \\frown $\\propto$ \\propto $\u0026lt;$ \u0026lt; $\u0026gt;$ \u0026gt; 5.数学符号表二 符号 显示方法 符号 显示方法 符号 显示方法 $\\arccos$ \\arccos $\\arcsin$ \\arcsin $\\arctan$ \\arctan $\\arg$ \\arg $\\cos$ \\cos $\\cosh$ \\cosh $\\cot$ \\cot $\\coth$ \\coth $\\csc$ \\csc $\\deg$ \\deg $\\det$ \\det $\\dim$ \\dim $\\exp$ \\exp $\\gcd$ \\gcd $\\hom$ \\hom $\\inf$ \\inf $\\ker$ \\ker $\\lg$ \\lg $\\lim$ \\lim $\\liminf$ \\liminf $\\limsup$ \\limsup $\\ln$ \\ln $\\log$ \\log $\\max$ \\max $\\min$ \\min $\\Pr$ \\pr $\\sec$ \\sec $\\sin$ \\sin $\\sinh$ \\sinh $\\sup$ \\sup $\\tan$ \\tan $\\tanh$ \\tanh —— —— 5.箭头符号表 符号 显示方法 符号 显示方法 符号 显示方法 $\\leftarrow$ \\leftarrow $\\longleftarrow$ \\longleftarrow $\\Leftarrow$ \\Leftarrow $\\Longleftarrow$ \\Longleftarrow $\\rightarrow$ \\rightarrow $\\longrightarrow$ \\longrightarrow $\\Rightarrow$ \\Rightarrow $\\Longrightarrow$ \\Longrightarrow $\\leftrightarrow$ \\leftrightarrow $\\longleftrightarrow$ \\longleftrightarrow $\\Leftrightarrow$ \\Leftrightarrow $\\Longleftrightarrow$ \\Longleftrightarrow $\\mapsto$ \\mapsto $\\longmapsto$ \\longmapsto $\\hookleftarrow$ \\hookleftarrow $\\hookrightarrow$ \\hookrightarrow $\\leftharpoonup$ \\leftharpoonup $\\rightharpoonup$ \\rightharpoonup $\\leftharpoondown$ \\leftharpoondown $\\rightharpoondown$ \\rightharpoondown $\\rightleftharpoons$ \\rightleftharpoons $\\leadsto$ \\leadsto $\\uparrow$ \\uparrow $\\downarrow$ \\downarrow $\\Uparrow$ \\Uparrow $\\Downarrow$ \\Downarrow $\\updownarrow$ \\updownarrow $\\Updownarrow$ \\Updownarrow $\\nwarrow$ \\nwarrow $\\nearrow$ \\nearrow $\\swarrow$ \\swarrow $\\searrow$ \\searrow —— —— 6.特殊符号表 符号 显示方法 符号 显示方法 符号 显示方法 $\\S$ \\S $\\aleph$ \\aleph $\\LaTeX$ \\LaTeX $\\ldots$ \\ldots $\\ddots$ \\ddots $\\cdots$ \\cdots $\\vdots$ \\vdots $\\imath$ \\imath $\\jmath$ \\jmath $\\ell$ \\ell $\\wp$ \\wp $\\Re$ \\Re $\\Im$ \\Im $\\Diamond$ \\Diamond $\\diamondsuit$ \\diamondsuit $\\prime$ \\prime $\\emptyset$ \\emptyset $\\nabla$ \\nabla $\\surd$ \\surd $\\top$ \\top $\\bot$ \\bot $\\backslash$ \\backslash $\\partial$ \\partial $\\infty$ \\infty $\\triangle$ \\triangle $\\heartsuit$ \\heartsuit $\\circledS$ \\circledS $\\hbar$ \\hbar $\\forall$ \\forall $\\exists$ \\exists $\\neg$ \\neg $\\flat$ \\flat $\\natural$ \\natural $\\sharp$ \\sharp $\\angle$ \\angle $\\mho$ \\mho $\\Box$ \\Box $\\clubsuit$ \\clubsuits $\\spadesuit$ \\spadesuit 7.希腊字母(Greek Letters)显示表 拉丁字母 小写显示方法 大写显示方法 大写字母 $\\alpha$ \\alpha —— —— $\\beta$ \\beta —— —— $\\gamma$ \\gamma \\Gamma $\\Gamma$ $\\delta$ \\delta \\Delta $\\Delta$ $\\epsilon$ \\epsilon —— —— $\\zeta$ \\zeta —— —— $\\eta$ \\eta —— —— $\\theta$ \\theta \\Theta $\\Theta$ $\\iota$ \\iota —— —— $\\kappa$ \\kappa —— —— $\\lambda$ \\lambda \\lambda $\\lambda$ $\\mu$ \\mu —— —— $\\nu$ \\nu —— —— $\\xi$ \\xi \\Xi $\\Xi$ $\\omicron$ \\omicron —— —— $\\pi$ \\pi \\Pi $\\Pi$ $\\rho$ \\rho —— —— $\\sigma$ \\sigma \\Sigma $\\Sigma$ $\\tau$ \\tau —— —— $\\upsilon$ \\upsilon \\Upsilon $\\Upsilon$ $\\phi$ \\phi \\Phi $\\Phi$ $\\chi$ \\chi —— —— $\\psi$ \\psi \\Psi $\\Psi$ $\\omega$ \\omega \\Omega $\\Omega$ 注意：将小写字母的首字母大写表示为大写拉丁字母\n8.常用结构例子 例1 1 2 3 4 5 6 7 8 9 $$ \\begin{align*} \\sqrt{37} \u0026amp;= \\sqrt{\\frac{73^2 - 1}{12^2}} \\\\ \u0026amp;= \\sqrt{\\frac{73^2}{12^2} \\cdot \\frac{73^2 - 1}{73^2}} \\\\ \u0026amp;= \\sqrt{\\frac{73^2}{12^2}} \\sqrt{\\frac{73^2 - 1}{73^2}} \\\\ \u0026amp;= \\frac{73}{12} \\sqrt{1 - \\frac{1}{73^2}} \\\\ \u0026amp;\\approx \\frac{73}{12} \\left(1 - \\frac{1}{2 \\cdot 73^2}\\right) \\end{align*} $$ $$\\begin{align} \\sqrt{37} \u0026 = \\sqrt{\\frac{73^2-1}{12^2}} \\\\\\\\ \u0026 = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\\\\\ \u0026 = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\\\\\ \u0026 = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\\\\\ \u0026 \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{align}$$例2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \\begin{matrix} 1 \u0026amp; x \u0026amp; x^2 \\\\ 1 \u0026amp; y \u0026amp; y^2 \\\\ 1 \u0026amp; z \u0026amp; z^2 \\\\ \\end{matrix} \\begin{pmatrix} 1 \u0026amp; x \u0026amp; x^2 \\\\ 1 \u0026amp; y \u0026amp; y^2 \\\\ 1 \u0026amp; z \u0026amp; z^2 \\\\ \\end{pmatrix} \\begin{bmatrix} 1 \u0026amp; x \u0026amp; x^2 \\\\ 1 \u0026amp; y \u0026amp; y^2 \\\\ 1 \u0026amp; z \u0026amp; z^2 \\\\ \\end{bmatrix} \\begin{Bmatrix} 1 \u0026amp; x \u0026amp; x^2 \\\\ 1 \u0026amp; y \u0026amp; y^2 \\\\ 1 \u0026amp; z \u0026amp; z^2 \\\\ \\end{Bmatrix} $$\\begin{matrix} 1 \u0026 x \u0026 x^2 \\\\ 1 \u0026 y \u0026 y^2 \\\\ 1 \u0026 z \u0026 z^2 \\\\ \\end{matrix}$$ $$\\begin{pmatrix} 1 \u0026 x \u0026 x^2 \\\\ 1 \u0026 y \u0026 y^2 \\\\ 1 \u0026 z \u0026 z^2 \\\\ \\end{pmatrix}$$ $$\\begin{bmatrix} 1 \u0026 x \u0026 x^2 \\\\ 1 \u0026 y \u0026 y^2 \\\\ 1 \u0026 z \u0026 z^2 \\\\ \\end{bmatrix}$$ $$\\begin{Bmatrix} 1 \u0026 x \u0026 x^2 \\\\ 1 \u0026 y \u0026 y^2 \\\\ 1 \u0026 z \u0026 z^2 \\\\ \\end{Bmatrix}$$ $$\\begin{vmatrix} 1 \u0026 x \u0026 x^2 \\\\ 1 \u0026 y \u0026 y^2 \\\\ 1 \u0026 z \u0026 z^2 \\\\ \\end{vmatrix}$$例3 1 2 3 4 5 6 \\left[ \\begin{array}{cc|c} 1\u0026amp;2\u0026amp;3\\\\ 4\u0026amp;5\u0026amp;6 \\end{array} \\right] $$\\left[ \\begin{array}{cc|c} 1\u00262\u00263\\\\ 4\u00265\u00266 \\end{array} \\right]$$ $$\\left[ \\begin{array}{c|cc} 2\u00264\u00267\\\\ 3\u00266\u002634 \\end{array} \\right]\\times\\left[ \\begin{array}{cc|c} 1\u00262\u00263\\\\ 4\u00265\u00266 \\end{array} \\right]$$例4 1 2 3 4 5 6 7 8 9 10 11 12 13 f(n) = \\begin{cases} n/2, \u0026amp; \\text{if $n$ is even} \\\\\\ 3n+1, \u0026amp; \\text{if $n$ is odd} \\end{cases} \\begin{array}{c|lcr} n \u0026amp; \\text{Left} \u0026amp; \\text{Center} \u0026amp; \\text{Right} \\\\\\ \\hline 1 \u0026amp; 0.24 \u0026amp; 1 \u0026amp; 125 \\\\\\ 2 \u0026amp; -1 \u0026amp; 189 \u0026amp; -8 \\\\\\ 3 \u0026amp; -20 \u0026amp; 2000 \u0026amp; 1+10i \\end{array} $$f(n) = \\begin{cases} n/2, \u0026 \\text{if $n$ is even} \\\\ 3n+1, \u0026 \\text{if $n$ is odd}\\end{cases}$$","date":"2022-08-22T21:29:24Z","permalink":"https://blogbook.eu.org/p/latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/","title":"LaTeX数学公式大全"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html\nWithin this partial reference the Auto-render Extension or host these scripts locally.\nInclude the partial in your templates like so:\nTo enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration\nTo enable KaTeX on a per page basis include the parameter math: true in content files\nNote: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://blogbook.eu.org/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://blogbook.eu.org/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://blogbook.eu.org/p/emoji-support/","title":"Emoji Support"}]